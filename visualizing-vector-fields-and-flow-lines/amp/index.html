<!DOCTYPE html>
<html âš¡>
<head>
    <meta charset="utf-8">

    <title>Visualizing Vector Fields and Flow Lines using Matplotlib</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
    <link rel="canonical" href="../" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Andrew Peng" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Visualizing Vector Fields and Flow Lines using Matplotlib" />
    <meta property="og:description" content="Using Matplotlib, a python plotting library, I figured out how to graph both 2d and 3d vector fields along with their associated flow lines. Intuitively, flow lines are curves which you get by starting at a point and tracing in the direction of the vector field. This is the path" />
    <meta property="og:url" content="https://andrewpeng.dev/visualizing-vector-fields-and-flow-lines/" />
    <meta property="og:image" content="https://andrewpeng.dev/content/images/2020/03/3-3.png" />
    <meta property="article:published_time" content="2020-03-31T19:58:00.000Z" />
    <meta property="article:modified_time" content="2020-12-20T16:18:36.000Z" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Visualizing Vector Fields and Flow Lines using Matplotlib" />
    <meta name="twitter:description" content="Using Matplotlib, a python plotting library, I figured out how to graph both 2d and 3d vector fields along with their associated flow lines. Intuitively, flow lines are curves which you get by starting at a point and tracing in the direction of the vector field. This is the path" />
    <meta name="twitter:url" content="https://andrewpeng.dev/visualizing-vector-fields-and-flow-lines/" />
    <meta name="twitter:image" content="https://andrewpeng.dev/content/images/2020/03/3-3.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Andrew Peng" />
    <meta property="og:image:width" content="572" />
    <meta property="og:image:height" content="558" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Andrew Peng",
        "logo": "https://static.ghost.org/v1.0.0/images/ghost-logo.svg"
    },
    "author": {
        "@type": "Person",
        "name": "Andrew Peng",
        "url": "https://andrewpeng.dev/author/andrew/",
        "sameAs": []
    },
    "headline": "Visualizing Vector Fields and Flow Lines using Matplotlib",
    "url": "https://andrewpeng.dev/visualizing-vector-fields-and-flow-lines/",
    "datePublished": "2020-03-31T19:58:00.000Z",
    "dateModified": "2020-12-20T16:18:36.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://andrewpeng.dev/content/images/2020/03/3-3.png",
        "width": 572,
        "height": 558
    },
    "description": "Using Matplotlib, a python plotting library, I figured out how to graph both 2d and 3d vector fields along with their associated flow lines. Intuitively, flow lines are curves which you get by starting at a point and tracing in the direction of the vector field. This is the path",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://andrewpeng.dev/"
    }
}
    </script>

    <meta name="generator" content="Ghost 2.28" />
    <link rel="alternate" type="application/rss+xml" title="Andrew Peng" href="../../rss/" />

    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,600,400" />
    <style amp-custom>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{margin:0.67em 0;font-size:2em}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{position:relative;vertical-align:baseline;font-size:75%;line-height:0}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}amp-img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;color:inherit;font:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em;border:1px solid #c0c0c0}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}html{max-height:100%;height:100%;font-size:62.5%;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}body{max-height:100%;height:100%;color:#3a4145;background:#f4f8fb;letter-spacing:0.01rem;font-family:"Merriweather", serif;font-size:1.8rem;line-height:1.75em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"kern" 1;-moz-font-feature-settings:"kern" 1;-o-font-feature-settings:"kern" 1}::-moz-selection{background:#d6edff}::selection{background:#d6edff}h1,h2,h3,h4,h5,h6{margin:0 0 0.3em 0;color:#2e2e2e;font-family:"Open Sans", sans-serif;line-height:1.15em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-moz-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-o-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1}h1{text-indent:-2px;letter-spacing:-1px;font-size:2.6rem}h2{letter-spacing:0;font-size:2.4rem}h3{letter-spacing:-0.6px;font-size:2.1rem}h4{font-size:1.9rem}h5{font-size:1.8rem}h6{font-size:1.8rem}a{color:#4a4a4a}a:hover{color:#111}p,ul,ol,dl{margin:0 0 2.5rem 0;font-size:1.5rem;text-rendering:geometricPrecision;-webkit-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-moz-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-o-font-feature-settings:"liga" 1, "onum" 1, "kern" 1}ol,ul{padding-left:2em}ol ol,ul ul,ul ol,ol ul{margin:0 0 0.4em 0;padding-left:2em}dl dt{float:left;clear:left;overflow:hidden;margin-bottom:1em;width:180px;text-align:right;text-overflow:ellipsis;white-space:nowrap;font-weight:700}dl dd{margin-bottom:1em;margin-left:200px}li{margin:0.4em 0}li li{margin:0}hr{display:block;margin:1.75em 0;padding:0;height:1px;border:0;border-top:#efefef 1px solid}blockquote{box-sizing:border-box;margin:1.75em 0 1.75em 0;padding:0 0 0 1.75em;border-left:#4a4a4a 0.4em solid;-moz-box-sizing:border-box}blockquote p{margin:0.8em 0;font-style:italic}blockquote small{display:inline-block;margin:0.8em 0 0.8em 1.5em;color:#ccc;font-size:0.9em}blockquote small:before{content:"\2014 \00A0"}blockquote cite{font-weight:700}blockquote cite a{font-weight:normal}mark{background-color:#fdffb6}code,tt{padding:1px 3px;border:#e3edf3 1px solid;background:#f7fafb;border-radius:2px;white-space:pre-wrap;font-family:Inconsolata, monospace, sans-serif;font-size:0.85em;font-feature-settings:"liga" 0;-webkit-font-feature-settings:"liga" 0;-moz-font-feature-settings:"liga" 0}pre{overflow:auto;box-sizing:border-box;margin:0 0 1.75em 0;padding:10px;width:100%;border:#e3edf3 1px solid;background:#f7fafb;border-radius:3px;white-space:pre;font-family:Inconsolata, monospace, sans-serif;font-size:0.9em;-moz-box-sizing:border-box}pre code,pre tt{padding:0;border:none;background:transparent;white-space:pre-wrap;font-size:inherit}kbd{display:inline-block;margin-bottom:0.4em;padding:1px 8px;border:#ccc 1px solid;background:#f4f4f4;border-radius:4px;box-shadow:0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 0 #fff inset;color:#666;text-shadow:#fff 0 1px 0;font-size:0.9em;font-weight:700}table{box-sizing:border-box;margin:1.75em 0;max-width:100%;width:100%;background-color:transparent;-moz-box-sizing:border-box}table th,table td{padding:8px;border-top:#efefef 1px solid;vertical-align:top;text-align:left;line-height:20px}table th{color:#000}table caption + thead tr:first-child th,table caption + thead tr:first-child td,table colgroup + thead tr:first-child th,table colgroup + thead tr:first-child td,table thead:first-child tr:first-child th,table thead:first-child tr:first-child td{border-top:0}table tbody + tbody{border-top:#efefef 2px solid}table table table{background-color:#fff}table tbody > tr:nth-child(odd) > td,table tbody > tr:nth-child(odd) > th{background-color:#f6f6f6}table.plain tbody > tr:nth-child(odd) > td,table.plain tbody > tr:nth-child(odd) > th{background:transparent}iframe,amp-iframe,.fluid-width-video-wrapper{display:block;margin:1.75em 0}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper amp-iframe{margin:0}textarea,select,input{margin:0 0 5px 0;padding:6px 9px;width:260px;outline:0;border:#e7eef2 1px solid;background:#fff;border-radius:4px;box-shadow:none;font-family:"Open Sans", sans-serif;font-size:1.6rem;line-height:1.4em;font-weight:100;-webkit-appearance:none}textarea{min-width:250px;min-height:80px;max-width:340px;width:100%;height:auto}input[type="text"]:focus,input[type="email"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="url"]:focus,input[type="password"]:focus,input[type="number"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="week"]:focus,input[type="time"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,textarea:focus{outline:none;outline-width:0;border:#bbc7cc 1px solid;background:#fff}select{width:270px;height:30px;line-height:30px}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.clearfix{zoom:1}.main-header{position:relative;display:table;overflow:hidden;box-sizing:border-box;width:100%;height:50px;background:#5ba4e5 no-repeat center center;background-size:cover;text-align:left;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}.content{background:#fff;padding-top:15px}.blog-title,.content{margin:auto;max-width:600px}.blog-title a{display:block;padding-right:16px;padding-left:16px;height:50px;color:#fff;text-decoration:none;font-family:"Open Sans", sans-serif;font-size:16px;line-height:50px;font-weight:600}.post{position:relative;margin-top:0;margin-right:16px;margin-left:16px;padding-bottom:0;max-width:100%;border-bottom:#ebf2f6 1px solid;word-wrap:break-word;font-size:0.95em;line-height:1.65em}.post-header{margin-bottom:1rem}.post-title{margin-bottom:0}.post-title a{text-decoration:none}.post-meta{display:block;margin:3px 0 0 0;color:#9eabb3;font-family:"Open Sans", sans-serif;font-size:1.3rem;line-height:2.2rem}.post-meta a{color:#9eabb3;text-decoration:none}.post-meta a:hover{text-decoration:underline}.post-meta .author{margin:0;font-size:1.3rem;line-height:1.3em}.post-date{display:inline-block;text-transform:uppercase;white-space:nowrap;font-size:1.2rem;line-height:1.2em}.post-image{margin:0;padding-top:3rem;padding-bottom:30px;border-top:1px #E8E8E8 solid}.post-content amp-img,.post-content amp-anim{position:relative;left:50%;display:block;padding:0;min-width:0;max-width:112%;width:calc(100% + 32px);height:auto;transform:translateX(-50%);-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%)}.footnotes{font-size:1.3rem;line-height:1.6em;font-style:italic}.footnotes li{margin:0.6rem 0}.footnotes p{margin:0}.footnotes p a:last-child{text-decoration:none}.site-footer{position:relative;margin:0 auto 20px auto;padding:1rem 15px;max-width:600px;color:rgba(0,0,0,0.5);font-family:"Open Sans", sans-serif;font-size:1.1rem;line-height:1.75em}.site-footer a{color:rgba(0,0,0,0.5);text-decoration:none;font-weight:bold}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.poweredby{display:block;float:right;width:45%;text-align:right}.copyright{display:block;float:left;width:45%}</style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="main-header">
        <nav class="blog-title">
            <a href="../../">Andrew Peng</a>
        </nav>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">Visualizing Vector Fields and Flow Lines using Matplotlib</h1>
                <section class="post-meta">
                    <p class="author">by <a href="../../author/andrew/">Andrew Peng</a></p>
                    <time class="post-date" datetime="2020-03-31">2020-03-31</time>
                </section>
            </header>
            <figure class="post-image">
                <amp-img src="https://andrewpeng.dev/content/images/2020/03/3-3.png" width="600" height="400" layout="responsive"></amp-img>
            </figure>
            <section class="post-content">

                <p>Using Matplotlib, a python plotting library, I figured out how to graph both 2d and 3d vector fields along with their associated <strong>flow lines</strong>. Intuitively, flow lines are curves which you get by starting at a point and tracing in the direction of the vector field. This is the path a particle would take in a vector field. </p><p>The formal definition of a flow line is this: Let \(\textbf{F}\) be a vector field and \(\textbf{x}(t)\) be the flow line. Then \( \textbf{x}'(t) = \textbf{F}(\textbf{x}(t)) \). In other words, at every point on the path \(\textbf{x}\), \(\textbf{x}\) is tangent to the vector field \(\mathbf{F}\).</p><figure class="kg-card kg-image-card kg-card-hascaption"><figcaption>The vector field \( \textbf{F}(x,y)=(1, x+y)\) with a flow line (green) through the point (0,0).</figcaption></figure><h2 id="graphing-in-2d">Graphing in 2d</h2><hr></hr><h3 id="graphing-a-simple-vector-field">Graphing a simple vector field</h3><p>First, we must import all of our dependencies, which are matplotlib and numpy.</p><pre><code class="language-Python">import matplotlib.pyplot as plt
import numpy as np</code></pre><p>Now we have to define the x and y components of our vector field as a function of Â the point (x,y). Â In this case, \(\text{F}(x, y) = (y, -x)\). We also define the x and y bounds as well as our step size (which defines our 'grid' of vectors) and scale (which scales the vectors in the graph).</p><pre><code class="language-Python ">vf_x = lambda x, y: y
vf_y = lambda x, y: -x

x_lim = (-10, 10)
y_lim = (-10, 10)

step = 2
scale = 3</code></pre><p>We create a grid using np.meshgrid, where each point in the grid is given by (X[i, j], Y[i, j]), where i and j are indices. We then assign the x component of every vector in the grid to U and the y component to V using our vector field function defined earlier. Matplotlib's quiver function creates the vector field. </p><pre><code class="language-Python">X, Y = np.meshgrid(np.arange(x_lim[0], x_lim[1], step), np.arange(y_lim[0], y_lim[1], step))
U = np.zeros(X.shape)
V = np.zeros(Y.shape)

for i in range(X.shape[0]):
	for j in range(Y.shape[0]):
        U[i,j] = vf_x(X[i, j], Y[i, j])
        V[i,j] = vf_y(X[i, j], Y[i, j])
        
fig, ax = plt.subplots(figsize=(20, 20))
_ = ax.quiver(X, Y, U, V, units='xy', scale=scale, color='red')

plt.xlim(x_lim)
plt.ylim(y_lim)</code></pre><p>Finally, we can plot the vector field and make it look at bit nicer.</p><pre><code class="language-Python">ax.set_xticks(np.arange(x_lim[0], x_lim[1], 1))
ax.set_yticks(np.arange(y_lim[0], y_lim[1], 1))
ax.set_aspect('equal')

# Move axis to the middle
ax.spines['left'].set_position('zero')

ax.spines['right'].set_color('none')
ax.yaxis.tick_left()

ax.spines['bottom'].set_position('zero')

ax.spines['top'].set_color('none')
ax.xaxis.tick_bottom()
plt.grid()

plt.show()
plt.close()</code></pre><p>This is the final result!</p><figure class="kg-card kg-image-card kg-card-hascaption"><figcaption>The vector field \( \textbf{F}(x,y)=(y, -x)\) with step=2 and scale=3</figcaption></figure><h3 id="graphing-functions">Graphing Functions</h3><p>We can also graph functions using plt.plot, including flow lines. func_x is an array of x values, and func_y is an array of y values.</p><pre><code class="language-Python">plt.plot(func_x, func_y, 'g')</code></pre><p>For example, this plots the flowline through (0, 0) for the vector field \( \textbf{F}(x, y) = (1, x+y)\). </p><figure class="kg-card kg-code-card"><pre><code class="language-Python">func_x = np.arange(-10, 10, 0.2)
func_y = 1*np.exp(func_x) - func_x - 1</code></pre><figcaption>The equation for the flow line is \(y=e^x - x -1\) (not derived)</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><figcaption>The vector field \( \textbf{F}(x, y) = (1, x+y)\) with a flow line through (0, 0)</figcaption></figure><h3 id="graphing-flow-lines-using-euler-s-method">Graphing Flow Lines using Euler's Method</h3><p>What if we can't find the equation to the flow line directly? We can use <a href="http://tutorial.math.lamar.edu/Classes/DE/EulersMethod.aspx">Euler's method</a>, and the premise behind Euler's method is this:</p><ol><li>Start at point (x, y)</li><li>Find the derivative, or slope, at (x, y). The vector field already gives us the x and y components of the derivative!</li><li>Take a step in the direction of the derivative, and get a new point (x, y)</li><li>Repeat steps 1-3 until either x or y are outside the desired bounds</li></ol><p>In python, it looks like this:</p><pre><code class="language-Python">def numerically_find_flow_line_2d(starting_point, step, vf_x, vf_y, x_lim, y_lim):
    func_x = []
    func_y = []
    
    # Find the points to the "right" of the point
    x = starting_point[0]
    y = starting_point[1]
    while True:
        func_x.append(x)
        func_y.append(y)
        
        delta_x = vf_x(x, y)
        delta_y = vf_y(x, y)
        
        # Normalize to unit vector and scale by 1/step
        magnitude = np.sqrt(delta_x ** 2 + delta_y ** 2)
        delta_x = delta_x / magnitude * step
        delta_y = delta_y / magnitude * step
        
        # Get the new point
        x = x + delta_x
        y = y + delta_y
        
        # Break if either x or y is outside of bounds
        if x &gt; x_lim[1] or x &lt; x_lim[0] or y &gt; y_lim[1] or y &lt; y_lim[0]:
            break
        
        # Break if it's taking too long for the curve to leave the bounds
        if len(func_x) &gt; 10000:
            break
    
    # Find the points to the "left" of the point- nearly identical 
    x = starting_point[0]
    y = starting_point[1]
    while True:
    	Here, we insert at the front because these points occur before the starting point instead of the back
        func_x.insert(0, x)
        func_y.insert(0, y)
        
        delta_x = vf_x(x, y)
        delta_y = vf_y(x, y)
        
        magnitude = np.sqrt(delta_x ** 2 + delta_y ** 2)
        delta_x = delta_x / magnitude * step
        delta_y = delta_y / magnitude * step
        
        # Here, we subtract delta instead of add
        x = x - delta_x
        y = y - delta_y
        
        if x &gt; 5 or x &lt; -5 or y &gt; 5 or y &lt; -5:
            break
        if len(func_x) &gt; 20000:
            break 
    
    return func_x, func_y</code></pre><p>Here's the result- it looks identical to the graph we generated by manually finding the flow line! As long as the step size is sufficiently large, the numerically generated flow line should be close to the actual flow line.</p><figure class="kg-card kg-image-card kg-card-hascaption"><figcaption>The vector field \( \textbf{F}(x, y) = (1, x+y)\) with a flow line through (0, 0)</figcaption></figure><h2 id="graphing-in-3d">Graphing in 3d</h2><hr></hr><p>Well, can we graph vector fields in 3d? Yes! To graph in 3d, we have to add a special import which we will use to create a 3d axis. Other than that, all we have to do is add an extra variable.</p><pre><code class="language-Python">from mpl_toolkits.mplot3d import Axes3D
def make_vf_3d(x_lim, y_lim, z_lim, step, vf_x, vf_y, vf_z, length, func_xs=None, func_ys=None, func_zs=None):
    X, Y, Z = np.meshgrid(np.arange(x_lim[0], x_lim[1], step), 
                          np.arange(y_lim[0], y_lim[1], step), 
                          np.arange(z_lim[0], z_lim[1], step))
    U = np.zeros(X.shape)
    V = np.zeros(Y.shape)
    W = np.zeros(Z.shape)
    
    # Assign vector components to the U, V, and W arrays
    for i in range(X.shape[0]):
        for j in range(Y.shape[0]):
                for k in range(Z.shape[0]):
                    U[i, j, k] = vf_x(X[i, j, k], Y[i, j, k], Z[i, j, k])
                    V[i, j, k] = vf_y(X[i, j, k], Y[i, j, k], Z[i, j, k])
                    W[i, j, k] = vf_z(X[i, j, k], Y[i, j, k], Z[i, j, k])

    fig = plt.figure(figsize=(10, 10))
    # 3d projection
    ax = fig.gca(projection='3d')
    
    # Plot the vector field
    ax.quiver(X, Y, Z, U, V, W, length=length, color='red')
    if func_x is not None:
       plt.plot(func_x, func_y, func_z, 'g')
        
    ax.set_xlim3d(x_lim)
    ax.set_xlim3d(y_lim)
    ax.set_zlim3d(z_lim)
    plt.grid()
    
    plt.show()
    plt.close()</code></pre><p>We can also use Euler's method in 3d as well. It's the same as the 2d way, but we're adding a z variable.</p><pre><code class="language-Python">def numerically_find_flow_line_3d(starting_point, step, vf_x, vf_y, vf_z, x_lim, y_lim, z_lim):
    func_x = []
    func_y = []
    func_z = []
    
    # Find points to the "right" of the starting point
    x = starting_point[0]
    y = starting_point[1]
    z = starting_point[2]
    while True:
        func_x.append(x)
        func_y.append(y)
        func_z.append(z)

        delta_x = vf_x(x, y, z)
        delta_y = vf_y(x, y, z)
        delta_z = vf_z(x, y, z)
        
        # Scale the deltas
        magnitude = np.sqrt(delta_x ** 2 + delta_y ** 2 + delta_z ** 2)
        delta_x = delta_x / magnitude * step
        delta_y = delta_y / magnitude * step
        delta_z = delta_z / magnitude * step

		# Find the new point
        x = x + delta_x
        y = y + delta_y
        z = z + delta_z
        
        # Break if the x, y, or z variable is out of bounds
        if x &gt; x_lim[1] or x &lt; x_lim[0] or \
           y &gt; y_lim[1] or y &lt; y_lim[0] or \
           z &gt; z_lim[1] or z &lt; z_lim[0]:
            break
            
        # Break if it's taking too long
        if len(func_x) &gt; 50000:
            break
    
    # Find points to the "left" of the starting point
    x = starting_point[0]
    y = starting_point[1]
    z = starting_point[2]
    while True:
        func_x.insert(0, x)
        func_y.insert(0, y)
        func_z.insert(0, z)

        delta_x = vf_x(x, y, z)
        delta_y = vf_y(x, y, z)
        delta_z = vf_z(x, y, z)
        
        magnitude = np.sqrt(delta_x ** 2 + delta_y ** 2 + delta_z ** 2)
        delta_x = delta_x / magnitude * step
        delta_y = delta_y / magnitude * step
        delta_z = delta_z / magnitude * step

        x = x - delta_x
        y = y - delta_y
        z = z - delta_z
        
        if x &gt; x_lim[1] or x &lt; x_lim[0] or \
           y &gt; y_lim[1] or y &lt; y_lim[0] or \
           z &gt; z_lim[1] or z &lt; z_lim[0]:
            break
        if len(func_x) &gt; 100000:
            break
    
    return func_x, func_y, func_z</code></pre><p>Here is a result:</p><figure class="kg-card kg-image-card kg-card-hascaption"><figcaption>Graphing the vector field \( \textbf{F}(x, y, z) = (x, 0, 3)\) with two different flow lines starting at \((1, 1, 2)\) and \((-3, 0, 2)\)</figcaption></figure>

            </section>

        </article>
    </main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="../../">Andrew Peng</a> &copy; 2020</section>
        <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
    </footer>
</body>
</html>
